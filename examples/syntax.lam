---------------------------------------------------
----- Examples of various parts of the syntax -----
---------------------------------------------------

--------------------
-- Function Types --
--------------------

-- the simplest function type has no named binders
ftySimple : Type 0 -> Type 0
ftySimple = \x -> x

-- we can then use named binders to allow later parts of the type to depend
-- upon earlier components
ftyDependent : (l : Level) -> Type l -> Type l
ftyDependent = \l -> \x -> x

-- when you have multiple named bindings of the same type, you
-- can group them as follows:
ftyDependentSameGrouped : (l1 l2 : Level) -> Type l1 -> Type l2 -> Type l1
ftyDependentSameGrouped = \l1 -> \l2 -> \x -> \y -> x

-- similarly, if you have multiple named binders, you can group them
-- without needing to put an arrow between them
ftyDependentMultiBinders : (l : Level) (a : Type l) -> a -> a
ftyDependentMultiBinders = \l -> \a -> \x -> x

-------------------------
-- Lambda Abstractions --
-------------------------

-- Lambda abstractions are introduced with a backslash,
-- followed by an argument, then the arrow and result expression.
lamSimple : Type 0 -> Type 0
lamSimple = \x -> x

-- you can use 'Church style' to give explicit types to the
-- arguments if you desire.
lamChurch : Type 0 -> Type 0
lamChurch = \(x : Type 0) -> x

-- similarly to function types, you can group arguments, though
-- the arguments don't need to have the same type
lamGroupArgs : Type 0 -> Type 1 -> Type 0
lamGroupArgs = \x y -> x

-- you can of course mix argument syntax as you wish
lamMixedArgs : (l1 l2 : Level) (a : Type l1) (b : Type l2) -> Type l2
lamMixedArgs = \(l1 l2 : Level) (a : Type l1) b -> b
